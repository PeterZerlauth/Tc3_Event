<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_Event" Id="{fcfa56ff-d0f1-4149-9de7-6f44354915c6}" SpecialFunc="None">
    <Declaration><![CDATA[
{attribute 'reflection'} 
// Providing the event logger
FUNCTION_BLOCK FB_Event IMPLEMENTS I_Event
VAR_INPUT
	iLogger:					I_Logger;		// Interface has to be attached to a Valid target
END_VAR
VAR
    {attribute 'hide'} 
    {attribute 'instance-path'} 
    {attribute 'noinit'} 
    sInstancePath:				STRING(255);
	fbSymbolInfo: 				PLC_ReadSymInfoByNameEx;
	fbSystemTime: 				FB_LocalSystemTime;
    {attribute 'hide'} 
	fbSourceInfo:				FB_TcSourceInfo;
	fbArguments:				FB_Argument;	
	fbVerbose:					FB_Message;
	fbInfo:						FB_Message;
	fbWarning:					FB_Message;
	fbError:					FB_Message;
	fbCritical:					FB_Message;
	fbTcVerbose:				FB_TcAlarm;
	fbTcInfo:					FB_TcAlarm;
	fbTcWarning:				FB_TcAlarm;
	fbTcError:					FB_TcAlarm;
	fbTcCritical:				FB_TcAlarm;
END_VAR
VAR_STAT
	nCycleTime:					UDINT;
	nTimestamp:					Tc2_Utilities.T_FILETIME64;		
END_VAR
(*
    Tc3_Event – TwinCAT 3 Event Logging Framework
    Copyright (c) Peter Zerlauth

    This component is provided under a Dual Licensing Model:

    1. GPLv3 Open-Source License
       - Free for personal, educational, and non-commercial use.
       - Commercial use allowed only if the entire application is published
         under GPLv3, including all modifications to this code.
       - Requires full disclosure of source code for derivative works.

    2. Commercial License
       - Required for integration into proprietary or closed-source products.
       - Removes all GPLv3 copyleft obligations.
       - Includes optional warranty, professional support, and long-term
         maintenance options.

    For commercial licensing, contact:
        info@peterzerlauth.com

    By using this Function Block you agree to the terms of the selected license.
*)
]]></Declaration>
    <Implementation>
      <ST><![CDATA[fbSymbolInfo();
IF nCycleTime <> TwinCAT_SystemInfoVarList._TaskInfo[GETCURTASKINDEXEX()].CycleTime THEN
	nCycleTime:= TwinCAT_SystemInfoVarList._TaskInfo[GETCURTASKINDEXEX()].CycleTime;
	fbSystemTime();
	nTimestamp:= SYSTEMTIME_TO_FILETIME64(fbSystemTime.systemTime);
	GVL.nTimestamp:= nTimestamp;	
END_IF


IF fbVerbose.bActive THEN
	fbVerbose.bActive:= FALSE;
ELSE
	IF fbTcVerbose.bActive THEN
		fbTcVerbose.Clear();
	END_IF
END_IF

IF fbInfo.bActive THEN
	fbInfo.bActive:= FALSE;
ELSE
	IF fbTcInfo.bActive THEN
		fbTcInfo.Clear();
	END_IF
END_IF

IF fbWarning.bActive THEN
	fbWarning.bActive:= FALSE;
ELSE
	IF fbTcWarning.bActive THEN
		fbTcWarning.Clear();
	END_IF
END_IF

IF fbError.bActive THEN
	fbError.bActive:= FALSE;
ELSE
	IF fbTcError.bActive THEN
		fbTcError.Clear();
	END_IF
END_IF

IF fbCritical.bActive THEN
	fbCritical.bActive:= FALSE;
ELSE
	IF fbTcCritical.bActive THEN
		fbTcCritical.Clear();
	END_IF
END_IF]]></ST>
    </Implementation>
    <Method Name="FB_Init" Id="{86bf7a82-ee08-4323-8f31-a4c33f4b211e}">
      <Declaration><![CDATA[//FB_Init is always available implicitly and it is used primarily for initialization.
//The return value is not evaluated. For a specific influence, you can also declare the
//methods explicitly and provide additional code there with the standard initialization
//code. You can evaluate the return value.
METHOD FB_Init: BOOL
VAR_INPUT
    bInitRetains: BOOL; // TRUE: the retain variables are initialized (reset warm / reset cold)
    bInCopyCode: BOOL:= TRUE;  // TRUE: the instance will be copied to the copy code afterward (online change)   
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbSymbolInfo.SYMNAME:= F_InstancePath(sInstancePath);
fbSymbolInfo.PORT:= TwinCAT_SystemInfoVarList._AppInfo.AdsPort;
fbSymbolInfo.START:= TRUE;
fbSystemTime.bEnable:= TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Critical" Id="{7b4c91bf-8e3c-413c-a148-e271617106d9}">
      <Declaration><![CDATA[METHOD PUBLIC M_Critical : BOOL
VAR_INPUT
	nID:				UDINT;				// Id of the error message
	sMessage:			STRING(255);		// content of the error message, placeholder %s
END_VAR
VAR
	sArgument:			STRING;
	nPosition: 			INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF sMessage = '' THEN
	RETURN;
END_IF

fbCritical.bActive:= TRUE;
fbCritical.sMessage:= sMessage;
fbCritical.eLogLevel:= E_LogLevel.Critical;
IF nID = 0 THEN
	fbCritical.nID:= F_Hash(sMessage);
ELSE
	fbCritical.nID:= nID;
END_IF
fbCritical.nTimestamp:= SYSTEMTIME_TO_FILETIME64(fbSystemTime.systemTime);
fbCritical.sArguments:= fbArguments.P_Value;
fbCritical.sDefault:= F_Print(sMessage, fbArguments.P_Value);
fbCritical.sSource:= fbSymbolInfo.SYMNAME;
fbCritical.sType:= fbSymbolInfo.SYMINFO.symDataType;

IF iLogger = 0 THEN
	F_Log(fbCritical);
ELSE
	iLogger.M_Log(fbCritical);
END_IF

// prepare
fbSourceInfo.Clear();
fbSourceInfo.sName:= fbCritical.sSource;
IF NOT fbTcCritical.EqualsToEventEntry(TC_EVENT_CLASSES.Tc3_Event, fbCritical.nID, TcEventSeverity.Critical) THEN
	fbTcCritical.Create(TC_EVENT_CLASSES.Tc3_Event, fbCritical.nID, TcEventSeverity.Critical, FALSE, fbSourceInfo);
END_IF

fbTcCritical.ipArguments.Clear();

// Split and add arguments
nPosition := FIND(fbCritical.sArguments, '$R');
WHILE nPosition > 0 DO
    sArgument := LEFT(fbCritical.sArguments, nPosition - 1);
    fbTcCritical.ipArguments.AddString(sArgument);
    fbCritical.sArguments:= RIGHT(fbCritical.sArguments, LEN(fbCritical.sArguments) - (nPosition + 1));
    nPosition := FIND(fbCritical.sArguments, '$R');
END_WHILE;

fbTcCritical.Raise(fbCritical.nTimestamp);
	
fbArguments.M_Clear();]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Error" Id="{11687e23-ea95-4e4f-aed4-4799ffa1ad84}">
      <Declaration><![CDATA[METHOD PUBLIC M_Error : BOOL
VAR_INPUT
	nID:				UDINT;				// Id of the error message
	sMessage:			STRING(255);		// content of the error message, placeholder %s
END_VAR
VAR
	sArgument:			STRING;
	nPosition: 			INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF sMessage = '' THEN
	RETURN;
END_IF

fbError.bActive:= TRUE;
fbError.sMessage:= sMessage;
fbError.eLogLevel:= E_LogLevel.Error;
IF nID = 0 THEN
	fbError.nID:= F_Hash(sMessage);
ELSE
	fbError.nID:= nID;
END_IF
fbError.nTimestamp:= SYSTEMTIME_TO_FILETIME64(fbSystemTime.systemTime);
fbError.sArguments:= fbArguments.P_Value;
fbError.sDefault:= F_Print(sMessage, fbArguments.P_Value);
fbError.sSource:= fbSymbolInfo.SYMNAME;
fbError.sType:= fbSymbolInfo.SYMINFO.symDataType;

IF iLogger = 0 THEN
	F_Log(fbError);
ELSE
	iLogger.M_Log(fbError);
END_IF

// prepare
fbSourceInfo.Clear();
fbSourceInfo.sName:= fbError.sSource;
IF NOT fbTcError.EqualsToEventEntry(TC_EVENT_CLASSES.Tc3_Event, fbError.nID, TcEventSeverity.Error) THEN
	fbTcError.Create(TC_EVENT_CLASSES.Tc3_Event, fbError.nID, TcEventSeverity.Error, FALSE, fbSourceInfo);
END_IF
fbTcError.ipArguments.Clear();

// Split and add arguments
nPosition := FIND(fbError.sArguments, '$R');
WHILE nPosition > 0 DO
    sArgument := LEFT(fbError.sArguments, nPosition - 1);
    fbTcError.ipArguments.AddString(sArgument);
    fbError.sArguments:= RIGHT(fbError.sArguments, LEN(fbError.sArguments) - (nPosition + 1));
    nPosition := FIND(fbError.sArguments, '$R');
END_WHILE;

fbTcError.Raise(fbError.nTimestamp);

fbArguments.M_Clear();]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Info" Id="{7a920e55-da6d-473b-9aba-119c4de007e0}">
      <Declaration><![CDATA[METHOD PUBLIC M_Info : BOOL
VAR_INPUT
	nID:				UDINT;				// Id of the error message
	sMessage:			STRING(255);		// content of the error message, placeholder %s
END_VAR
VAR
	sArgument:			STRING;
	nPosition: 			INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF sMessage = '' THEN
	RETURN;
END_IF

fbInfo.bActive:= TRUE;
fbInfo.sMessage:= sMessage;
fbInfo.eLogLevel:= E_LogLevel.Info;
IF nID = 0 THEN
	fbInfo.nID:= F_Hash(sMessage);
ELSE
	fbInfo.nID:= nID;
END_IF
fbInfo.nTimestamp:= SYSTEMTIME_TO_FILETIME64(fbSystemTime.systemTime);
fbInfo.sArguments:= fbArguments.P_Value;
fbInfo.sDefault:= F_Print(sMessage, fbArguments.P_Value);
fbInfo.sSource:= fbSymbolInfo.SYMNAME;
fbInfo.sType:= fbSymbolInfo.SYMINFO.symDataType;

IF iLogger = 0 THEN
	F_Log(fbInfo);
ELSE
	iLogger.M_Log(fbInfo);
END_IF

// prepare
fbSourceInfo.Clear();
fbSourceInfo.sName:= fbInfo.sSource;
IF NOT fbTcInfo.EqualsToEventEntry(TC_EVENT_CLASSES.Tc3_Event, fbInfo.nID, TcEventSeverity.Info) THEN
	fbTcInfo.Create(TC_EVENT_CLASSES.Tc3_Event, fbInfo.nID, TcEventSeverity.Info, FALSE, fbSourceInfo);
END_IF
fbTcInfo.ipArguments.Clear();

// Split and add arguments
nPosition := FIND(fbInfo.sArguments, '$R');
WHILE nPosition > 0 DO
    sArgument := LEFT(fbInfo.sArguments, nPosition - 1);
    fbTcInfo.ipArguments.AddString(sArgument);
    fbInfo.sArguments:= RIGHT(fbInfo.sArguments, LEN(fbInfo.sArguments) - (nPosition + 1));
    nPosition := FIND(fbInfo.sArguments, '$R');
END_WHILE;

fbTcInfo.Raise(fbInfo.nTimestamp);

fbArguments.M_Clear();]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Reset" Id="{3a4a22c9-fd2e-42d4-aaa7-202418505488}">
      <Declaration><![CDATA[METHOD M_Reset : BOOL
VAR_INPUT
END_VAR
VAR
	fbReset:					FB_Message;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbReset.bActive:= TRUE;
fbReset.sMessage:= '###Reset###';
fbReset.eLogLevel:= E_LogLevel.Error;
fbReset.nID:= F_Hash(fbReset.sMessage);
fbReset.nTimestamp:= 0;
fbReset.sArguments:= '';
fbReset.sDefault:= '';
fbReset.sSource:= fbSymbolInfo.SYMNAME;
fbReset.sType:= fbSymbolInfo.SYMINFO.symDataType;

IF iLogger <> 0 THEN
	M_Reset:= iLogger.M_Log(fbReset);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Verbose" Id="{db95e385-16ed-493b-a6a5-28cc6625776b}">
      <Declaration><![CDATA[METHOD PUBLIC M_Verbose : BOOL
VAR_INPUT
	sMessage:			STRING(255);		// content of the error message, placeholder %s
END_VAR
VAR
	sArgument:			STRING;
	nPosition: 			INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF sMessage = '' THEN
	RETURN;
END_IF

fbVerbose.bActive:= TRUE;
fbVerbose.sMessage:= sMessage;
fbVerbose.eLogLevel:= E_LogLevel.Verbose;
fbVerbose.nID:= F_Hash(sMessage);
fbVerbose.nTimestamp:= SYSTEMTIME_TO_FILETIME64(fbSystemTime.systemTime);
fbVerbose.sArguments:= fbArguments.P_Value;
fbVerbose.sDefault:= F_Print(sMessage, fbArguments.P_Value);
fbVerbose.sSource:= fbSymbolInfo.SYMNAME;
fbVerbose.sType:= fbSymbolInfo.SYMINFO.symDataType;

IF iLogger = 0 THEN
	F_Log(fbVerbose);
ELSE
	iLogger.M_Log(fbVerbose);
END_IF

// prepare
fbSourceInfo.Clear();
fbSourceInfo.sName:= fbVerbose.sSource;
IF NOT fbTcVerbose.EqualsToEventEntry(TC_EVENT_CLASSES.Tc3_Event, fbVerbose.nID, TcEventSeverity.Verbose) THEN
	fbTcVerbose.Create(TC_EVENT_CLASSES.Tc3_Event, fbVerbose.nID, TcEventSeverity.Verbose, FALSE, fbSourceInfo);
END_IF
fbTcVerbose.ipArguments.Clear();

// Split and add arguments
nPosition := FIND(fbVerbose.sArguments, '$R');
WHILE nPosition > 0 DO
    sArgument := LEFT(fbVerbose.sArguments, nPosition - 1);
    fbTcVerbose.ipArguments.AddString(sArgument);
    fbVerbose.sArguments:= RIGHT(fbVerbose.sArguments, LEN(fbVerbose.sArguments) - (nPosition + 1));
    nPosition := FIND(fbVerbose.sArguments, '$R');
END_WHILE;

fbTcVerbose.Raise(fbVerbose.nTimestamp);


fbArguments.M_Clear();]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Warning" Id="{1aa0d3ef-0f74-4102-97d7-7d587822db85}">
      <Declaration><![CDATA[METHOD PUBLIC M_Warning : BOOL
VAR_INPUT
	nID:				UDINT;
	sMessage:			STRING(255);		// content of the error message, placeholder %s
END_VAR
VAR
	sArgument:			STRING;
	nPosition: 			INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF sMessage = '' THEN
	RETURN;
END_IF

fbWarning.bActive:= TRUE;
fbWarning.sMessage:= sMessage;
fbWarning.eLogLevel:= E_LogLevel.Warning;
IF nID = 0 THEN
	fbWarning.nID:= F_Hash(sMessage);
ELSE
	fbWarning.nID:= nID;
END_IF
fbWarning.nTimestamp:= SYSTEMTIME_TO_FILETIME64(fbSystemTime.systemTime);
fbWarning.sArguments:= fbArguments.P_Value;
fbWarning.sDefault:= F_Print(sMessage, fbArguments.P_Value);
fbWarning.sSource:= fbSymbolInfo.SYMNAME;
fbWarning.sType:= fbSymbolInfo.SYMINFO.symDataType;

IF iLogger = 0 THEN
	F_Log(fbWarning);
ELSE
	iLogger.M_Log(fbWarning);
END_IF

// prepare
fbSourceInfo.Clear();
fbSourceInfo.sName:= fbWarning.sSource;
IF NOT fbTcWarning.EqualsToEventEntry(TC_EVENT_CLASSES.Tc3_Event, fbWarning.nID, TcEventSeverity.Warning) THEN
	fbTcWarning.Create(TC_EVENT_CLASSES.Tc3_Event, fbWarning.nID, TcEventSeverity.Warning, FALSE, fbSourceInfo);
END_IF
fbTcWarning.ipArguments.Clear();

// Split and add arguments
nPosition := FIND(fbWarning.sArguments, '$R');
WHILE nPosition > 0 DO
    sArgument := LEFT(fbWarning.sArguments, nPosition - 1);
    fbTcWarning.ipArguments.AddString(sArgument);
    fbWarning.sArguments:= RIGHT(fbWarning.sArguments, LEN(fbWarning.sArguments) - (nPosition + 1));
    nPosition := FIND(fbWarning.sArguments, '$R');
END_WHILE;

fbTcWarning.Raise(fbWarning.nTimestamp);

fbArguments.M_Clear();]]></ST>
      </Implementation>
    </Method>
    <Property Name="P_Argument" Id="{dd3bce54-33d7-4a6c-8d06-ad6a5d0ec566}">
      <Declaration><![CDATA[PROPERTY PUBLIC P_Argument : I_Argument]]></Declaration>
      <Get Name="Get" Id="{9148b4be-b1fa-4fe4-a389-e96c939bba14}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_Argument:= fbArguments;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="P_Logger" Id="{98c079df-4944-4aae-a3d6-ca12ac41d1d4}">
      <Declaration><![CDATA[PROPERTY PUBLIC P_Logger : I_Logger]]></Declaration>
      <Get Name="Get" Id="{7f49254e-94b6-4972-a1b5-02a92d10e780}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_Logger:= iLogger;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{4bbb606c-4053-49cc-ae04-84e1809ace25}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[iLogger:= P_Logger;]]></ST>
        </Implementation>
      </Set>
    </Property>
  </POU>
</TcPlcObject>